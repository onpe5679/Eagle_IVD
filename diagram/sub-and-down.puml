@startuml
skinparam sequenceArrowThickness 2
skinparam ParticipantPadding 10
skinparam BoxPadding 10

title 구독 확인/다운로드/임포트 - 단순화된 실제 흐름 (중복 Phase 제거 + 실시간 DB 반영)

actor 사용자
participant "클라이언트 UI" as UI
participant "SubscriptionManager" as SubManager
participant "SubscriptionChecker" as Checker
participant "DownloadManager" as DLManager
participant "VideoDownloadQueue" as Queue
participant "SubscriptionImporter" as Importer
participant "yt-dlp 프로세스" as ytdlp
participant "YouTube 서버" as YouTube
participant "구독 DB" as DB
participant "파일 시스템" as FS
participant "Eagle Library" as Eagle

== 사전 구성 ==
note over SubManager,DLManager
SubManager.setDownloadManager(downloadManager)
- this.downloadManager = downloadManager
- this.checker = new SubscriptionChecker(downloadManager, updateStatusUI, importer, libraryId)

DLManager.initialize()
- downloadFolder 생성
- downloadQueue = new VideoDownloadQueue(DLManager)
- Queue 이벤트를 DLManager가 UI로 중계

Importer = new SubscriptionImporter(updateStatusUI, prefixUploadDate)
end note

== 구독 추가 (변경 없음) ==
사용자 -> UI: "구독 추가" 클릭
activate UI
UI -> SubManager: addSubscription({ url, folderName, format, quality })
activate SubManager
SubManager -> DLManager: getMetadata(url)
activate DLManager
DLManager -> ytdlp: --print-json --skip-download --flat-playlist --playlist-end 1 url
activate ytdlp
ytdlp -> YouTube: 메타데이터 요청
activate YouTube
YouTube --> ytdlp: JSON 메타데이터
deactivate YouTube
ytdlp --> DLManager: JSON
deactivate ytdlp
DLManager --> SubManager: 메타데이터 객체
deactivate DLManager

SubManager -> DB: addPlaylist({...})
DB --> SubManager: playlist.id
SubManager -> SubManager: this.subscriptions.push(newSub)
SubManager --> UI: emit('subscriptionAdded', newSub)
UI --> 사용자: "구독이 추가되었습니다"
deactivate SubManager
deactivate UI

== 새 영상 확인/다운로드/임포트 (단순화된 파이프라인) ==
사용자 -> UI: "새 비디오 확인" 클릭
activate UI
UI -> SubManager: checkAllSubscriptions(progressCallback, {concurrency, metadataBatchSize, downloadBatchSize, rateLimit, enableSorting})
activate SubManager

SubManager -> SubManager: loadSubscriptions()
SubManager -> DB: getPlaylistsByLibrary(libraryId) 또는 getAllPlaylists()
DB --> SubManager: 구독 목록
SubManager -> Checker: checkAllSubscriptions(subscriptions, progressCallback, options)
activate Checker

note over Checker
isChecking = true
- 단일 Phase A에서 각 구독의 ID 목록과 DB 상태를 함께 수집
- 이후 정렬(옵션) 및 배치(concurrency) 처리
end note

group Phase A: "ID 수집 + DB 비교" (한 번만)
  loop 모든 구독 (병렬)
    Checker -> ytdlp: --skip-download --flat-playlist --print-json
    activate ytdlp
    ytdlp -> YouTube: 엔트리/ID 요청
    YouTube --> ytdlp: JSON 라인 스트림
    ytdlp --> Checker: fetchedIds
    deactivate ytdlp

    Checker -> DB: getCompletedVideoIds(sub.id)  // downloaded=1 AND eagle_linked=1
    DB --> Checker: completedSet
    Checker -> Checker: newVideoIds = fetchedIds - completedSet
    Checker -> Checker: newVideoCount = newVideoIds.length
    note right
    이후 checkSubscription 호출 시
    preFetchedIds로 reuse → 재요청 최소화
    end note
  end
  alt enableSorting != false
    Checker -> Checker: newVideoCount 오름차순 정렬 (빠른 피드백/안정성)
  else
    Checker -> Checker: 원래 순서(FIFO) 처리
  end
end

loop 배치 처리 (concurrency 동시)
  group 각 구독 처리 (checkSubscription)
    activate Checker

    alt newVideoIds 비어있음
      Checker -> UI: updateStatusUI("신규 영상 없음")
      Checker --> SubManager: {newVideos:0, stats.totalVideosFound=fetchedIds.length}
      deactivate Checker
    else
      group Phase B: 새 영상 상세 메타데이터 (배치 = metadataBatchSize)
        loop 배치
          Checker -> ytdlp: --skip-download --print-json --newline (배치 URL들)
          activate ytdlp
          ytdlp -> YouTube: 상세 메타데이터 요청
          YouTube --> ytdlp: 상세 JSON 라인 스트림
          ytdlp --> Checker: downloadedMetadata[id] 갱신
          deactivate ytdlp
        end
      end

      group Phase C: 큐 다운로드 + 즉시 임포트 + 실시간 DB 반영
        Checker -> DLManager: applyUISettings()  // 동시 다운로드/속도제한 UI값 적용
        Checker -> DLManager: downloadQueue.setImporter(Importer)
        opt rateLimit > 0
          Checker -> DLManager: downloadQueue.setRateLimit(rateLimit)
        end

        Checker -> Checker: playlistInfo = {id(playlistId), playlistDbId=sub.id, ...}

        loop newVideoIds
          Checker -> DLManager: downloadQueue.queue.push(new VideoDownloadItem(metadata, playlistInfo))
          DLManager -> DLManager: downloadQueue.stats.total++
        end

        alt Queue 미실행
          Checker -> DLManager: downloadQueue.setMaxConcurrent(downloadBatchSize) + start()
          activate Queue
          DLManager -> UI: "Download queue started"
        end

        note over Queue,DLManager
        Queue.processQueue()가 VideoDownloadItem 단위로 yt-dlp를 병렬 실행
        videoCompleted / videoFailed 이벤트 발생
        end note

        loop 각 영상 완료 이벤트
          Queue -> DLManager: videoCompleted(videoItem)
          DLManager -> Checker: 이벤트 전달
          ... (내부 처리) ...
          DLManager -> DB: markVideoDownloadComplete(videoId,'completed')
          DLManager -> Importer: importAndRemoveDownloadedFiles(...)
          Importer -> Eagle: folder.getAll / create / item.addFromPath or update(save)
          Importer -> DB: markVideoAsEagleLinked(videoId)
          Importer -> FS: fs.unlink(file)  // 다운로드 파일 삭제
          DLManager -> DB: incrementPlaylistVideos(playlistDbId, +1)  // videos 즉시 증가
        end

        loop 각 영상 실패 이벤트
          Queue -> DLManager: videoFailed(videoItem)
          DLManager -> DB: markVideoDownloadComplete(videoId,'failed', reason)
          DLManager -> DB: releaseVideoProcessingLock(videoId) (필요 시)
        end
      end

      group Phase D: 구독 요약 업데이트 (간소화)
        Checker -> Checker: sub.lastCheck = Date.now()
        Checker --> SubManager: { stats.totalVideosFound=fetchedIds.length, ... }
        SubManager -> DB: updatePlaylistSummary(sub.id, { last_checked, videos_from_yt })
        DB --> SubManager: OK
      end
      deactivate Checker
    end
  end
end

Checker -> Checker: isChecking = false
Checker --> SubManager: results[]
deactivate Checker

== 마무리 ==
SubManager -> SubManager: saveSubscriptions(results)
note right of SubManager
- videos는 이미 per-video 임포트 완료 시 즉시 증가 처리됨
- 여기서는 last_checked, videos_from_yt만 갱신
end note
SubManager --> UI: emit('checkComplete')
UI --> 사용자: "작업 완료"
deactivate SubManager
deactivate UI

== 메모 ==
note over Checker,DLManager
- Phase A에서 수집한 fetchedIds는 checkSubscription에서 preFetchedIds로 재사용하여 재요청 최소화
- enableSorting 옵션으로 정렬 비활성화 가능(FIFO)
- 실시간 DB 반영:
  • 영상 성공 시: downloaded=1 + eagle_linked=1(임포트 후) + playlists.videos += 1
  • 실패 시: status=failed + 처리락 해제
- 일괄 갱신(saveSubscriptions)은 요약 필드만 업데이트
end note

@enduml
